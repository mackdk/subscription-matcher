package com.suse.matcher.deduction.rules;

import com.suse.matcher.deduction.facts.Message;
import com.suse.matcher.deduction.facts.PinnedMatch;
import com.suse.matcher.deduction.facts.Subscription;
import com.suse.matcher.deduction.facts.SubscriptionProduct;

import java.util.TreeMap;

import function com.suse.matcher.deduction.DeductionPhaseLogger.info;

// Agenda group for converting old style hard bundles (consisting of more subscriptions)
// into a single-subscription hard bundle

rule "markHardBundledCandidates"
    agenda-group "HardBundleConversion"
    when
        // for a subscription we look for another subscription with same attributes
        // if there is such a subscription, the original subscription is a hard bundle candidate
        $candidate : Subscription(ignored == false, hardBundleId == null, singleSubscriptionHardBundle == false)
        Subscription( // try to find subscription in the same hard bundle
            id != $candidate.getId(),
            ignored == false,
            partNumber == $candidate.getPartNumber(),
            startDate == $candidate.getStartDate(),
            endDate == $candidate.getEndDate(),
            quantity == $candidate.getQuantity(),
            singleSubscriptionHardBundle == false)
    then
        // each hard bundle candidate will start with hard bundle id equal to its own id, later we'll merge them together
        modify ($candidate) {
            setHardBundleId($candidate.getId());
        }
end

// MERGING HARD BUNDLES
// For reproducibility,  we merge 2 hard bundles together such that the hard bundle with higher id gets merged
// into the one with lower id. This way we make sure the hard bundle id is equal to the lowest
// subscription ("leading subscription") id of all subscriptions in it.
rule "mergeHardBundles"
    agenda-group "HardBundleConversion"
    when
        // find 2 subscriptions with same attributes
        $leadingSub : Subscription(hardBundleId == id, ignored == false)
        $mergingSub : Subscription(ignored == false,
            hardBundleId > $leadingSub.getHardBundleId(),
            partNumber == $leadingSub.getPartNumber(),
            startDate == $leadingSub.getStartDate(),
            endDate == $leadingSub.getEndDate(),
            quantity == $leadingSub.getQuantity())

        // when the products of subscriptions are disjoint
        not (
            SubscriptionProduct(subscriptionId == $leadingSub.getId(), $productId : productId)  and
            SubscriptionProduct(subscriptionId == $mergingSub.getId(), productId == $productId)
        )

        // .. and the products of the subscription to be merged are not empty
        accumulate(
            $mergingSP : SubscriptionProduct(subscriptionId == $mergingSub.id);
            $mergingSPs : collectSet($mergingSP),
            $count : count($mergingSP);
            $count > 0
        )
    then
        // ... we "merge" mergingSub hard bundle to leading subscription
        modify($mergingSub) {
            setHardBundleId($leadingSub.getHardBundleId());
        }
        modify ($leadingSub) {
            setSingleSubscriptionHardBundle(true)
        }

        for (Object mergingSP : $mergingSPs) {
            insert(new SubscriptionProduct($leadingSub.getId(), ((SubscriptionProduct) mergingSP).getProductId()));
            retract(mergingSP);
        }
end

rule "mergePinnedMatches"
    agenda-group "HardBundleConversion"
    when
        // id of the "main" subscription in the hard bundle is equal to the hard bundle id
        Subscription(ignored == false, hardBundleId == id, $hardBundleId : hardBundleId)
        Subscription(ignored == false, id != $hardBundleId, hardBundleId == $hardBundleId, $subToRetractId : id)
        $pinnedMatch : PinnedMatch(subscriptionId == $subToRetractId)
    then
        TreeMap<String, String> data = new TreeMap<>();
        data.put("old_subscription_id", String.valueOf($subToRetractId));
        data.put("new_subscription_id", String.valueOf($hardBundleId));
        data.put("system_id", String.valueOf($pinnedMatch.getSystemId()));
        insert(new Message(Message.Level.INFO, "adjust_pinned_match", data));
        info(kcontext, "Modifying pinned subscription for system {} from {} to {} - Hard bundle", $pinnedMatch.getSystemId(), $subToRetractId, $hardBundleId);

        // we cannot use modify() because of attributes in hashCode, retract and insert instead
        insert(new PinnedMatch($pinnedMatch.getSystemId(), $hardBundleId));
        retract($pinnedMatch);
end

rule "removeRedundantSubscriptions"
    agenda-group "HardBundleConversion"
    when
        // out all of the subscriptions in a hard bundle, we keep the one with lowest id
        $leadingSub: Subscription(ignored == false, hardBundleId == id, singleSubscriptionHardBundle == true)
        $subToRetract : Subscription(ignored == false, id > $leadingSub.getId(), hardBundleId == $leadingSub.getHardBundleId())
    then
        TreeMap<String, String> data = new TreeMap<>();
        data.put("old_subscription_id", String.valueOf($subToRetract.getId()));
        data.put("new_subscription_id", String.valueOf($leadingSub.getId()));
        insert(new Message(Message.Level.INFO, "hb_merge_subscriptions", data));
        info(kcontext, "Merging subscription {} into {} - Hard bundle", $subToRetract.getId(), $leadingSub.getId());

        if ($leadingSub.getName() != null && $subToRetract.getName() != null) {
            modify($leadingSub) {
                setName($leadingSub.getName() + " + " + $subToRetract.getName())
            }
        }
        retract($subToRetract);
end

